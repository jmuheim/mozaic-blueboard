// Make sure to start the BlueBoard while pressing the B button!
@OnLoad
  SetShortName {GTLWizard}

  // Poor man's regression testing:
  // Enable to print a lot of messages to the log, then compare output to previous output (e.g. before and after refactoring code).
  // In addition you can put the logger script between this script and the receivers and compare its output to the previous one, too.
  debug = YES
  if debug
    Log {OnLoad}
  endif

  Call @InitConstants
  Call @InitVariables
  Call @InitGtlMidiCodes
  Call @InitAumMidiCodes

  Call @OnLoadMetroPulse

  Call @ResetGtlSession
  Call @IlluminateAllbuttons

  midiToSend = AUM_WELCOME
  Call @AnnounceMidi

  Call @AskForInput

  // Uncomment this to run through some settings quickly, so you can check whether they are applied correctly
  Call @InitTestData
@End

@InitConstants
  if debug
    Log {InitConstants}
  endif

  UNDEFINED = -1

  // Do not use the notes 60, 62, 64, and 65 for anything else (like MIDI bindings), as they are used for illuminating the BlueBoard buttons (see @IlluminateAllbuttons)!
  BB_NOTE_A = 60
  BB_NOTE_B = 62
  BB_NOTE_C = 64
  BB_NOTE_D = 65

  1_BEAT_TAP_TIME   = 1000 / (HostTempo / 60)
  4_BEATS_TAP_TIME  = 4 * 1_BEAT_TAP_TIME

  TAP_IMMEDIATE = 0
  TAP_1_BAR  = 1
  TAP_4_BARS = 2

  STEP_LOOP = 1
  LOOP_1 = 1
  LOOP_2 = 2
  LOOP_3 = 3
  LOOP_4 = 4

  STEP_GROUP = 2
  GROUP_M = 1
  GROUP_1 = 2
  GROUP_2 = 3
  GROUP_3 = 4
  GROUP_4 = 5
  GROUP_5 = 6

  STEP_CLOCK_LENGTH = 3
  CLOCK_LENGTH_1  = 1
  CLOCK_LENGTH_2  = 2
  CLOCK_LENGTH_4  = 4
  CLOCK_LENGTH_8  = 8
  CLOCK_LENGTH_10 = 10
  CLOCK_LENGTH_12 = 12
  CLOCK_LENGTH_16 = 16

  STEP_REC_SENDS = 4
  REC_SENDS_GUITAR           = 1
  REC_SENDS_MIC              = 2
  REC_SENDS_MIC_AND_GUITAR   = 3
  REC_SENDS_KEYBOARD         = 4
  REC_SENDS_MIC_AND_KEYBOARD = 5

  STEP_INSTR_FX = 5
  INSTR_FX_1 = 1
  INSTR_FX_2 = 2
  INSTR_FX_3 = 3
  INSTR_FX_4 = 4
  INSTR_FX_5 = 5
  INSTR_FX_6 = 6

  STEP_REC_MODE = 6
  REC_MODE_RECORD_OVERDUB     = 1
  REC_MODE_RECORD_MUTE        = 2
  REC_MODE_RECORD_SELECT_NEXT = 3

  FIRST_STEP = STEP_LOOP
  LAST_STEP  = STEP_REC_MODE

  // MIDI channels => Be aware that in the apps all channels are displayed as +1! So GTL channel will display 2 (instead of 1).
  BB_CHANNEL  = 0 // BlueBoard (listens only to channel 0)
  GTL_CHANNEL = 1 // Group The Loop
  AUM_CHANNEL = 4 // AUM

  // Feedback (Chameleon with preset "Group The Loop Wizard") => Make sure that AUM only sends this channel (3) to the respective Chameleon instance!
  // Chameleon only supports 34 audio files per preset (see https://forum.audiob.us/discussion/comment/835351/#Comment_835351).
  // So we have to load more than one, each with its own channel.
  FB_CHANNEL_0_TO_33  = 2
  FB_CHANNEL_34_TO_XX = 3
@End

// These are the codes that are sent as MIDI to GTL.
// GTL needs to have respective MIDI bindings assigned to these codes!
@InitGtlMidiCodes
  if debug
    Log {InitGtlMidiCodes}
  endif

  GTL_SELECT_LOOP_QUESTION = 42
  GTL_SELECT_LOOP_1 = 6
  GTL_SELECT_LOOP_2 = 7
  GTL_SELECT_LOOP_3 = 8
  GTL_SELECT_LOOP_4 = 9

  GTL_SELECT_GROUP_QUESTION = 43
  GTL_SELECT_GROUP_M = 0
  GTL_SELECT_GROUP_1 = 1
  GTL_SELECT_GROUP_2 = 2
  GTL_SELECT_GROUP_3 = 3
  GTL_SELECT_GROUP_4 = 4
  GTL_SELECT_GROUP_5 = 5

  GTL_SET_CLOCK_QUESTION = 44
  GTL_DECREASE_CLOCK = 10
  GTL_INCREASE_CLOCK = 11
  GTL_SET_CLOCK_2  = 33
  GTL_SET_CLOCK_4  = 34
  GTL_SET_CLOCK_8  = 35
  GTL_SET_CLOCK_10 = 36
  GTL_SET_CLOCK_12 = 37
  GTL_SET_CLOCK_16 = 38

  GTL_RECORD_QUESTION = 45
  GTL_RECORD_OVERDUB     = 12
  GTL_RECORD_MUTE        = 13
  GTL_RECORD_SELECT_NEXT = 14

  GTL_RESET_SESSION = 15
@End

@InitAumMidiCodes
  if debug
    Log {InitAumMidiCodes}
  endif

  AUM_SEND_QUESTION = 46
  AUM_SEND_GUITAR           = 16
  AUM_SEND_MIC              = 17
  AUM_SEND_MIC_AND_GUITAR   = 18
  AUM_SEND_KEYBOARD         = 19
  AUM_SEND_MIC_AND_KEYBOARD = 20

  GTL_GUITAR_FX_QUESTION = 47
  AUM_GUITAR_FX_1 = 21
  AUM_GUITAR_FX_2 = 22
  AUM_GUITAR_FX_3 = 23
  AUM_GUITAR_FX_4 = 24
  AUM_GUITAR_FX_5 = 25
  AUM_GUITAR_FX_6 = 26

  GTL_KEYBOARD_FX_QUESTION = 48
  AUM_KEYBOARD_FX_1 = 27
  AUM_KEYBOARD_FX_2 = 28
  AUM_KEYBOARD_FX_3 = 29
  AUM_KEYBOARD_FX_4 = 30
  AUM_KEYBOARD_FX_5 = 31
  AUM_KEYBOARD_FX_6 = 32

  AUM_WELCOME = 39
  AUM_CYCLE_ARMING_STARTED = 40
  AUM_CYCLE_ARMING_COMPLETE = 51
  AUM_CYCLE_ADDED_AGAIN = 41
  AUM_NO_CYCLE_PROVIDED = 50
  AUM_NO_CYCLE_LEFT = 49
@End

@InitVariables
  if debug
    Log {InitVariables}
  endif

  midiToSend = UNDEFINED
  midiDelay = 0

  microphoneActive = NO
  guitarInstrActive = NO
  keyboardInstrActive = NO

  stackSize = 0
  lastActivatedStackId = 0 // TODO: Shouldn't this be UNDEFINED?
  currentStep = FIRST_STEP

  currentClockLength = 1 // GTL sets clock length to 1 when resetting session

  firstArmPress = YES // Press "D" button the first time to arm CUE'able things in GTL; press second time to arm the rest immediately before the start of the next bar!
  armRecSendsAndInstrFx = NO

  lastSelectedGroup       = UNDEFINED
  lastSelectedLoop        = UNDEFINED
  lastSelectedClockLength = UNDEFINED
  lastSelectedRecSends    = UNDEFINED
  lastSelectedInstrFx     = UNDEFINED
  lastSelectedRecMode     = UNDEFINED

  groupStack       = []
  loopStack        = []
  clockLengthStack = []
  gtlSendsStack    = []
  instrFxStack     = []
  recModeStack     = []
@End

@InitTestData
  if debug
    Log {InitTestData}
  endif

  // Mmmmh (intro)
  groupStack[0]       = GROUP_1
  loopStack[0]        = LOOP_1
  clockLengthStack[0] = CLOCK_LENGTH_4
  gtlSendsStack[0]    = REC_SENDS_MIC_AND_KEYBOARD
  instrFxStack[0]     = INSTR_FX_1 // Warm pipes
  recModeStack[0]     = REC_MODE_RECORD_OVERDUB

  // Repeat
  groupStack[1]       = GROUP_1
  loopStack[1]        = LOOP_2
  clockLengthStack[1] = CLOCK_LENGTH_4
  gtlSendsStack[1]    = REC_SENDS_MIC_AND_KEYBOARD
  instrFxStack[1]     = INSTR_FX_2 // Marimba
  recModeStack[1]     = REC_MODE_RECORD_OVERDUB

  // By the rivers...
  groupStack[2]       = GROUP_2
  loopStack[2]        = LOOP_1
  clockLengthStack[2] = CLOCK_LENGTH_8
  gtlSendsStack[2]    = REC_SENDS_MIC_AND_GUITAR
  instrFxStack[2]     = INSTR_FX_6 // Wish you were here
  recModeStack[2]     = REC_MODE_RECORD_OVERDUB

  // Repeat
  groupStack[3]       = GROUP_2
  loopStack[3]        = LOOP_2
  clockLengthStack[3] = CLOCK_LENGTH_8
  gtlSendsStack[3]    = REC_SENDS_MIC
  instrFxStack[3]     = INSTR_FX_1 // Bob Marley
  recModeStack[3]     = REC_MODE_RECORD_OVERDUB

  // When the wicked...
  groupStack[4]       = GROUP_3
  loopStack[4]        = LOOP_1
  clockLengthStack[4] = CLOCK_LENGTH_8
  gtlSendsStack[4]    = REC_SENDS_MIC_AND_GUITAR
  instrFxStack[4]     = INSTR_FX_6 // Wish you were here
  recModeStack[4]     = REC_MODE_RECORD_OVERDUB

  // Repeat
  groupStack[5]       = GROUP_3
  loopStack[5]        = LOOP_2
  clockLengthStack[5] = CLOCK_LENGTH_8
  gtlSendsStack[5]    = REC_SENDS_MIC_AND_KEYBOARD
  instrFxStack[5]     = INSTR_FX_2 // Marimba
  recModeStack[5]     = REC_MODE_RECORD_OVERDUB

  stackSize = 7
@End

@ResetGtlSession
  if debug
    Log {ResetGtlSession}
  endif

  midiToSend = GTL_RESET_SESSION

  if debug
    Log {Resetting session by sending MIDI to GTL: }, midiToSend
  endif

  Call @SendMidiNoteOnOffToGtl
@End

@SendMidiNoteOnOffToGtl
  if debug
    Log {SendMidiNoteOnOffToGtl}
    Log {- midiToSend: }, midiToSend
  endif

  SendMidiNoteOn  GTL_CHANNEL, midiToSend, 100
  SendMidiNoteOff GTL_CHANNEL, midiToSend, 0, 0
@End

@SendMidiNoteOnToAum
  if debug
    Log {SendMidiNoteOnToAum}
    Log {- midiToSend: }, midiToSend
  endif

  SendMidiNoteOn AUM_CHANNEL, midiToSend, 100
@End

@SendMidiNoteOffToAum
  if debug
    Log {SendMidiNoteOnOffToAum}
    Log {- midiToSend: }, midiToSend
  endif

  SendMidiNoteOff AUM_CHANNEL, midiToSend, 0, 0
@End

@SendMidiNoteOnOffToAum
  if debug
    Log {SendMidiNoteOnOffToAum}
    Log {- midiToSend: }, midiToSend
  endif

  Call @SendMidiNoteOnToAum
  Call @SendMidiNoteOffToAum
@End

@AnnounceMidiWithDelay
  if debug
    Log {AnnounceMidiWithDelay}
  endif

  if midiDelay = 0
    midiDelay = 1000
  endif

  if debug
    Log {- midiDelay: }, midiDelay
  endif

  Call @AnnounceMidi
  midiDelay = 0
@End

@AnnounceMidi
  if debug
    Log {AnnounceMidi}
  endif

  if midiToSend < 34
    channel = FB_CHANNEL_0_TO_33
  else
    channel = FB_CHANNEL_34_TO_XX
  endif

  if debug
    Log {- Channel: }, channel, {, midiToSend: }, midiToSend
  endif

  SendMidiNoteOn  channel, midiToSend, 100, midiDelay
  SendMidiNoteOff channel, midiToSend, 0, midiDelay + 3000 // Chameleon needs a short delay between on and off, otherwise it doesn't trigger. To make sure the samples are played all through, we use quite a long delay.
@End

@IlluminateAllbuttons
  if debug
    Log {IlluminateAllbuttons}
  endif

  SendMidiNoteOn BB_CHANNEL, BB_NOTE_A, 100
  SendMidiNoteOn BB_CHANNEL, BB_NOTE_B, 100
  SendMidiNoteOn BB_CHANNEL, BB_NOTE_C, 100
  SendMidiNoteOn BB_CHANNEL, BB_NOTE_D, 100
@End

@OnMidiNoteOn
  if debug
    Log {OnMidiNoteOn}
    Log {- MidiNote: }, MidiNote
  endif

  buttonPressedStartTime = SystemTime // Time at which button was pressed down
@End

@OnMidiNoteOff
  if debug
    Log {OnMidiNoteOff}
    Log {- MidiNote: }, MidiNote
  endif

  buttonPressedTime = SystemTime - buttonPressedStartTime

  If buttonPressedTime >= 4_BEATS_TAP_TIME
    tapType = TAP_4_BARS
  Elseif buttonPressedTime >= 1_BEAT_TAP_TIME
    tapType = TAP_1_BAR
  Else
    tapType = TAP_IMMEDIATE
  Endif

  if debug
    Log {- tapType: }, tapType
  endif

  Call @DispatchButtonPress
@End

@DispatchButtonPress
  if debug
    Log {DispatchButtonPress}
  endif

  wrongInputDetected = YES

  if debug
    Log {- MidiNote: }, MidiNote
  endif

  if MidiNote = BB_NOTE_D
    if tapType = TAP_IMMEDIATE
      Call @ArmCycle
    elseif tapType = TAP_4_BARS
      Call @AddCycle
    else
      Log {- ERROR! Unknown tapType: }, tapType
    endif
  else
    if currentStep = STEP_LOOP
      Call @MapUserInputToLoop
    elseif currentStep = STEP_GROUP
      Call @MapUserInputToGroup
    elseif currentStep = STEP_CLOCK_LENGTH
      Call @MapUserInputToClockLength
    elseif currentStep = STEP_REC_SENDS
      Call @MapUserInputToRecSends
    elseif currentStep = STEP_INSTR_FX
      Call @MapUserInputToInstrFx
    elseif currentStep = STEP_REC_MODE
      Call @MapUserInputToRecMode
    else
      Log {- ERROR! Unknown currentStep: }, currentStep
    endif

    if wrongInputDetected = YES
      Log {Wrong input! Try again.}
    else
      if currentStep < LAST_STEP
        if debug
          Log {- Increase currentStep from }, currentStep
        endif

        Inc currentStep
      else
        Call @AddCycle
      endif

      Call @AskForInput
    endif
  endif
@End

@MapUserInputToRecSends
  if debug
    Log {MapUserInputToRecSends}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedRecSends = REC_SENDS_GUITAR
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedRecSends = REC_SENDS_MIC
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedRecSends = REC_SENDS_MIC_AND_GUITAR
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    if MidiNote = BB_NOTE_A
      lastSelectedRecSends = REC_SENDS_KEYBOARD
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      // Some day maybe some voice FX, e.g. Vocoder?
    elseif MidiNote = BB_NOTE_C
      lastSelectedRecSends = REC_SENDS_MIC_AND_KEYBOARD
      wrongInputDetected = NO
    endif
  endif

  if debug
    Log {- lastSelectedRecSends: }, lastSelectedRecSends, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedRecSends
  endif
@End

@MapUserInputToRecMode
  if debug
    Log {MapUserInputToRecMode}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedRecMode = REC_MODE_RECORD_OVERDUB
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedRecMode = REC_MODE_RECORD_MUTE
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedRecMode = REC_MODE_RECORD_SELECT_NEXT
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    // TODO: Advanced stuff!
  endif

  if debug
    Log {- lastSelectedRecMode: }, lastSelectedRecMode, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedRecMode
  endif
@End

@MapUserInputToInstrFx
  if debug
    Log {MapUserInputToInstrFx}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedInstrFx = INSTR_FX_1
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedInstrFx = INSTR_FX_2
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedInstrFx = INSTR_FX_3
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    if MidiNote = BB_NOTE_A
      lastSelectedInstrFx = INSTR_FX_4
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedInstrFx = INSTR_FX_5
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedInstrFx = INSTR_FX_6
      wrongInputDetected = NO
    endif
  endif

  if debug
    Log {- lastSelectedInstrFx: }, lastSelectedInstrFx, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedInstrFx
  endif
@End

@MapUserInputToLoop
  if debug
    Log {MapUserInputToLoop}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedLoop = LOOP_1
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedLoop = LOOP_2
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedLoop = LOOP_3
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    if MidiNote = BB_NOTE_A
      lastSelectedLoop = LOOP_4
      wrongInputDetected = NO
    endif
  endif

  if debug
    Log {- lastSelectedLoop: }, lastSelectedLoop, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedLoop
  endif
@End

@MapUserInputToClockLength
  if debug
    Log {MapUserInputToClockLength}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedClockLength = CLOCK_LENGTH_2
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedClockLength = CLOCK_LENGTH_4
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedClockLength = CLOCK_LENGTH_8
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    if MidiNote = BB_NOTE_A
      lastSelectedClockLength = CLOCK_LENGTH_10
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedClockLength = CLOCK_LENGTH_12
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedClockLength = CLOCK_LENGTH_16
      wrongInputDetected = NO
    endif
  endif

  if debug
    Log {- lastSelectedClockLength: }, lastSelectedClockLength, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedClockLength
  endif
@End

@MapUserInputToGroup
  if debug
    Log {MapUserInputToGroup}
  endif

  if tapType = TAP_IMMEDIATE
    if MidiNote = BB_NOTE_A
      lastSelectedGroup = GROUP_1
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedGroup = GROUP_2
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedGroup = GROUP_3
      wrongInputDetected = NO
    endif
  elseif tapType = TAP_1_BAR
    if MidiNote = BB_NOTE_A
      lastSelectedGroup = GROUP_M
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_B
      lastSelectedGroup = GROUP_4
      wrongInputDetected = NO
    elseif MidiNote = BB_NOTE_C
      lastSelectedGroup = GROUP_5
      wrongInputDetected = NO
    endif
  endif

  if debug
    Log {- lastSelectedGroup: }, lastSelectedGroup, {, wrongInputDetected: }, wrongInputDetected
  endif

  if wrongInputDetected = NO
    Call @AnnounceSelectedGroup
  endif
@End

@AskForInput
  if debug
    Log {AskForInput}
  endif

  if debug
    Log {- currentStep: }, currentStep
  endif

  if currentStep = STEP_LOOP
    midiToSend = GTL_SELECT_LOOP_QUESTION

    if stackSize > 0
      midiDelay = 3000
    endif

    Call @AnnounceMidiWithDelay
  elseif currentStep = STEP_GROUP
    midiToSend = GTL_SELECT_GROUP_QUESTION
    Call @AnnounceMidiWithDelay
  elseif currentStep = STEP_CLOCK_LENGTH
    midiToSend = GTL_SET_CLOCK_QUESTION
    Call @AnnounceMidiWithDelay
  elseif currentStep = STEP_REC_SENDS
    midiToSend = AUM_SEND_QUESTION
    Call @AnnounceMidiWithDelay
  elseif currentStep = STEP_INSTR_FX
    if guitarInstrActive
      midiToSend = GTL_GUITAR_FX_QUESTION
    elseif keyboardInstrActive
      midiToSend = GTL_KEYBOARD_FX_QUESTION
    endif

    Call @AnnounceMidiWithDelay
  elseif currentStep = STEP_REC_MODE
    midiToSend = GTL_RECORD_QUESTION
    Call @AnnounceMidiWithDelay
  else
    Log {- ERROR! Unknown currentStep: }, currentStep
  endif
@End

@AddCycle
  if debug
    Log {AddCycle}
  endif

  configPartMissing = NO

  if lastSelectedLoop = UNDEFINED
    configPartMissing = YES
    Log {No loop selected yet!}
  else
    loopStack[stackSize] = lastSelectedLoop
  endif

  if lastSelectedGroup = UNDEFINED
    configPartMissing = YES
    Log {No group selected yet!}
  else
    groupStack[stackSize] = lastSelectedGroup
  endif

  if lastSelectedClockLength = UNDEFINED
    configPartMissing = YES
    Log {No clock length selected yet!}
  else
    clockLengthStack[stackSize] = lastSelectedClockLength
  endif

  if lastSelectedRecSends = UNDEFINED
    configPartMissing = YES
    Log {No GTL sends selected yet!}
  else
    gtlSendsStack[stackSize] = lastSelectedRecSends
  endif

  if lastSelectedInstrFx = UNDEFINED
    configPartMissing = YES
    Log {No instr fx selected yet!}
  else
    instrFxStack[stackSize] = lastSelectedInstrFx
  endif

  if lastSelectedRecMode = UNDEFINED
    configPartMissing = YES
    Log {No rec mode selected yet!}
  else
    recModeStack[stackSize] = lastSelectedRecMode
  endif

  if debug
    Log {- configPartMissing}
  endif

  if configPartMissing = NO
    currentStep = FIRST_STEP
    Inc stackSize

    midiToSend = AUM_CYCLE_ADDED_AGAIN
    midiDelay = 1500
    Call @AnnounceMidiWithDelay

    if debug
      Log {- stackSize: }, stackSize, {, lastSelectedLoop: }, lastSelectedLoop, {, lastSelectedGroup: }, lastSelectedGroup, {, lastSelectedClockLength: }, lastSelectedClockLength, {, lastSelectedRecSends: }, lastSelectedRecSends, {, lastSelectedInstrFx: }, lastSelectedInstrFx, {, lastSelectedRecMode: }, lastSelectedRecMode
    endif
  endif
@End

@ArmCycle
  if debug
    Log {ArmCycle}
  endif

  if debug
    Log {- stackSize: }, stackSize, {, firstArmPress: }, firstArmPress, {, lastActivatedStackId: }, lastActivatedStackId
  endif

  if stackSize = 0
    midiToSend = AUM_NO_CYCLE_PROVIDED
    Call @AnnounceMidi

    midiDelay = 3000
    Call @AskForInput
  elseif lastActivatedStackId = stackSize
    midiToSend = AUM_NO_CYCLE_LEFT
    Call @AnnounceMidi

    midiDelay = 2000
    Call @AskForInput
  else
    if debug
      Log {Arming cycle #}, lastActivatedStackId
    endif

    if firstArmPress = YES
      Call @ArmGroup // Needs to be before @ArmLoop!
      Call @ArmLoop
      Call @ArmClockLength
      Call @AnnounceRecSends
      Call @AnnounceInstrFx
      Call @ArmRecMode

      midiToSend = AUM_CYCLE_ARMING_STARTED
      Call @AnnounceMidi

      firstArmPress = NO
    else
      firstArmPress = YES
      armRecSendsAndInstrFx = YES

      midiToSend = AUM_CYCLE_ARMING_COMPLETE
      Call @AnnounceMidi

      Inc lastActivatedStackId
    endif
  endif
@End

@AnnounceSelectedLoop
  if debug
    Log {AnnounceSelectedLoop}
  endif

  newLoop = lastSelectedLoop
  Call @MapLoopToMidi

  Call @AnnounceMidi
@End

@AnnounceSelectedGroup
  if debug
    Log {AnnounceSelectedGroup}
  endif

  newGroup = lastSelectedGroup
  Call @MapGroupToMidi

  Call @AnnounceMidi
@End

@AnnounceSelectedClockLength
  if debug
    Log {AnnounceSelectedClockLength}
  endif

  newClockLength = lastSelectedClockLength

  if newClockLength = CLOCK_LENGTH_2
    midiToSend = GTL_SET_CLOCK_2
  elseif newClockLength = CLOCK_LENGTH_4
    midiToSend = GTL_SET_CLOCK_4
  elseif newClockLength = CLOCK_LENGTH_8
    midiToSend = GTL_SET_CLOCK_8
  elseif newClockLength = CLOCK_LENGTH_10
    midiToSend = GTL_SET_CLOCK_10
  elseif newClockLength = CLOCK_LENGTH_12
    midiToSend = GTL_SET_CLOCK_12
  elseif newClockLength = CLOCK_LENGTH_16
    midiToSend = GTL_SET_CLOCK_16
  endif

  Call @AnnounceMidi
@End

@AnnounceSelectedRecSends
  if debug
    Log {AnnounceSelectedRecSends}
  endif

  newRecSends = lastSelectedRecSends
  Call @MapRecSendsToMidi

  Call @AnnounceMidi
@End

@AnnounceSelectedInstrFx
  if debug
    Log {AnnounceSelectedInstrFx}
  endif

  newInstrFx = lastSelectedInstrFx
  Call @MapInstrFxToMidi

  Call @AnnounceMidi
@End

@AnnounceSelectedRecMode
  if debug
    Log {AnnounceSelectedRecMode}
  endif

  newRecMode = lastSelectedRecMode
  Call @MapRecModeToMidi

  Call @AnnounceMidi
@End

@ArmLoop
  if debug
    Log {ArmLoop}
  endif

  newLoop = loopStack[lastActivatedStackId]
  Call @MapLoopToMidi

  if debug
    Log {Selecting loop by sending MIDI to GTL: }, midiToSend
  endif

  Call @SendMidiNoteOnOffToGtl
@End

@ArmGroup
  if debug
    Log {ArmGroup}
  endif

  newGroup = groupStack[lastActivatedStackId]
  Call @MapGroupToMidi

  if debug
    Log {Selecting group by sending MIDI to GTL: }, midiToSend
  endif

  Call @SendMidiNoteOnOffToGtl
@End

@ArmClockLength
  if debug
    Log {ArmClockLength}
  endif

  newClockLength = clockLengthStack[lastActivatedStackId]
  Call @MapClockLengthToMidi

  if debug
    Log {Setting clock length from }, currentClockLength, { to }, newClockLength, { by sending MIDI to GTL: }, midiToSend, { (*}, timesToSend, {)}
  endif

  for i = 1 to timesToSend
    Call @SendMidiNoteOnOffToGtl
  endfor

  currentClockLength = newClockLength
@End

@AnnounceRecSends
  if debug
    Log {AnnounceRecSends}
  endif

  newRecSends = gtlSendsStack[lastActivatedStackId]
  Call @MapRecSendsToMidi

  Call @AnnounceMidiWithDelay
@End

@ArmRecSends
  if debug
    Log {ArmRecSends}
  endif

  newRecSends = gtlSendsStack[lastActivatedStackId]
  Call @MapRecSendsToMidi

  // Make sure that AUM does not toggle, and that it does invert!

  midiToSend = AUM_SEND_GUITAR
  if guitarInstrActive
    Call @SendMidiNoteOnToAum
  else
    Call @SendMidiNoteOffToAum
  endif

  midiToSend = AUM_SEND_KEYBOARD
  if keyboardInstrActive
    Call @SendMidiNoteOnToAum
  else
    Call @SendMidiNoteOffToAum
  endif

  midiToSend = AUM_SEND_MIC
  if microphoneActive
    Call @SendMidiNoteOnToAum
  else
    Call @SendMidiNoteOffToAum
  endif
@End

@AnnounceInstrFx
  if debug
    Log {AnnounceInstrFx}
  endif

  newInstrFx = instrFxStack[lastActivatedStackId]
  Call @MapInstrFxToMidi

  midiDelay = 2000
  Call @AnnounceMidiWithDelay
@End

@ArmInstrFx
  if debug
    Log {ArmInstrFx}
  endif

  newInstrFx = instrFxStack[lastActivatedStackId]
  Call @MapInstrFxToMidi

  Call @SendMidiNoteOnOffToAum
@End

@ArmRecMode
  if debug
    Log {ArmRecMode}
  endif

  newRecMode = recModeStack[lastActivatedStackId]
  Call @MapRecModeToMidi

  midiDelay = 3000
  Call @AnnounceMidiWithDelay

  if debug
    Log {Starting record mode by sending MIDI to GTL: }, midiToSend
  endif

  Call @SendMidiNoteOnOffToGtl
@End

@MapLoopToMidi
  if debug
    Log {MapLoopToMidi}
  endif

  if newLoop = LOOP_1
    midiToSend = GTL_SELECT_LOOP_1
  elseif newLoop = LOOP_2
    midiToSend = GTL_SELECT_LOOP_2
  elseif newLoop = LOOP_3
    midiToSend = GTL_SELECT_LOOP_3
  elseif newLoop = LOOP_4
    midiToSend = GTL_SELECT_LOOP_4
  endif

  if debug
    Log {- midiToSend: }, midiToSend
  endif
@End

@MapGroupToMidi
  if debug
    Log {MapGroupToMidi}
  endif

  if newGroup = GROUP_M
    midiToSend = GTL_SELECT_GROUP_M
  elseif newGroup = GROUP_1
    midiToSend = GTL_SELECT_GROUP_1
  elseif newGroup = GROUP_2
    midiToSend = GTL_SELECT_GROUP_2
  elseif newGroup = GROUP_3
    midiToSend = GTL_SELECT_GROUP_3
  elseif newGroup = GROUP_4
    midiToSend = GTL_SELECT_GROUP_4
  elseif newGroup = GROUP_5
    midiToSend = GTL_SELECT_GROUP_5
  endif

  if debug
    Log {- midiToSend: }, midiToSend
  endif
@End

@MapClockLengthToMidi
  if debug
    Log {MapClockLengthToMidi}
  endif

  difference = newClockLength - currentClockLength

  if difference > 0
    midiToSend = GTL_INCREASE_CLOCK
    timesToSend = difference
  elseif difference < 0
    midiToSend = GTL_DECREASE_CLOCK
    timesToSend = difference * -1
  else
    timesToSend = 0
  Endif

  if debug
    Log {- midiToSend: }, midiToSend
    Log {- timesToSend: }, timesToSend
  endif
@End

@MapRecSendsToMidi
  if debug
    Log {MapRecSendsToMidi}
  endif

  if newRecSends = REC_SENDS_GUITAR
    guitarInstrActive = YES
    keyboardInstrActive = NO
    microphoneActive = NO
    midiToSend = AUM_SEND_GUITAR
  elseif newRecSends = REC_SENDS_MIC
    guitarInstrActive = NO
    keyboardInstrActive = NO
    microphoneActive = YES
    midiToSend = AUM_SEND_MIC
  elseif newRecSends = REC_SENDS_MIC_AND_GUITAR
    guitarInstrActive = YES
    keyboardInstrActive = NO
    microphoneActive = YES
    midiToSend = AUM_SEND_MIC_AND_GUITAR
  elseif newRecSends = REC_SENDS_KEYBOARD
    guitarInstrActive = NO
    keyboardInstrActive = YES
    microphoneActive = NO
    midiToSend = AUM_SEND_KEYBOARD
  elseif newRecSends = REC_SENDS_MIC_AND_KEYBOARD
    guitarInstrActive = NO
    keyboardInstrActive = YES
    microphoneActive = YES
    midiToSend = AUM_SEND_MIC_AND_KEYBOARD
  endif

  if debug
    Log {- guitarInstrActive: }, guitarInstrActive
    Log {- keyboardInstrActive: }, keyboardInstrActive
    Log {- microphoneActive: }, microphoneActive
    Log {- midiToSend: }, midiToSend
  endif
@End

@MapInstrFxToMidi
  if debug
    Log {MapInstrFxToMidi}
  endif

  if debug
    Log {- guitarInstrActive: }, guitarInstrActive
    Log {- keyboardInstrActive: }, keyboardInstrActive
  endif

  if guitarInstrActive
    Call @MapGuitarFxToMidi

    if debug
      Log {Selecting guitar FX by sending MIDI to AUM: }, midiToSend
    endif
  elseif keyboardInstrActive
    Call @MapKeyboardFxToMidi

    if debug
      Log {Selecting keyboard FX by sending MIDI to AUM: }, midiToSend
    endif
  endif
@End

@MapGuitarFxToMidi
  if debug
    Log {MapGuitarFxToMidi}
  endif

  if newInstrFx = INSTR_FX_1
    midiToSend = AUM_GUITAR_FX_1
  elseif newInstrFx = INSTR_FX_2
    midiToSend = AUM_GUITAR_FX_2
  elseif newInstrFx = INSTR_FX_3
    midiToSend = AUM_GUITAR_FX_3
  elseif newInstrFx = INSTR_FX_4
    midiToSend = AUM_GUITAR_FX_4
  elseif newInstrFx = INSTR_FX_5
    midiToSend = AUM_GUITAR_FX_5
  elseif newInstrFx = INSTR_FX_6
    midiToSend = AUM_GUITAR_FX_6
  endif

  if debug
    Log {- midiToSend: }, midiToSend
  endif
@End

@MapKeyboardFxToMidi
  if debug
    Log {MapKeyboardFxToMidi}
  endif

  if newInstrFx = INSTR_FX_1
    midiToSend = AUM_KEYBOARD_FX_1
  elseif newInstrFx = INSTR_FX_2
    midiToSend = AUM_KEYBOARD_FX_2
  elseif newInstrFx = INSTR_FX_3
    midiToSend = AUM_KEYBOARD_FX_3
  elseif newInstrFx = INSTR_FX_4
    midiToSend = AUM_KEYBOARD_FX_4
  elseif newInstrFx = INSTR_FX_5
    midiToSend = AUM_KEYBOARD_FX_5
  elseif newInstrFx = INSTR_FX_6
    midiToSend = AUM_KEYBOARD_FX_6
  endif

  if debug
    Log {- midiToSend: }, midiToSend
  endif
@End

@MapRecModeToMidi
  if debug
    Log {MapRecModeToMidi}
  endif

  if newRecMode = LOOP_1
    midiToSend = GTL_RECORD_OVERDUB
  elseif newRecMode = LOOP_2
    midiToSend = GTL_RECORD_MUTE
  elseif newRecMode = LOOP_3
    midiToSend = GTL_RECORD_SELECT_NEXT
  endif

  if debug
    Log {- midiToSend: }, midiToSend
  endif
@End

@OnLoadMetroPulse
  if debug
    Log {OnLoadMetroPulse}
  endif

  ppqn = 4
  SetMetroPPQN ppqn    
  pulsePerBar = HostBeatsPerMeasure * ppqn
@End

@OnMetroPulse
  // Log HostBar, {:}, HostBeat, { - }, CurrentMetroPulse, { - }, pulsePerBar

  if CurrentMetroPulse = pulsePerBar - 1
    if armRecSendsAndInstrFx
      if debug
        Log {Now arming rec mode and instr fx!}
      endif

      Call @ArmRecSends
      Call @ArmInstrFx

      armRecSendsAndInstrFx = NO
    endif
  endif
@End 

@OnNewBar
  // Log { ---- New Bar }
@End
